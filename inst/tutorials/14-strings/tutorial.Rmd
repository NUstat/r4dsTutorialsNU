---
title: Strings
tutorial:
  id: strings
output:
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
    css: ["css/nu-theme.css"]
runtime: shiny_prerendered
description: 'Tutorial for Chapter 14: Strings'
---

<!-- Modification of r4ds.tutorials author: Anish Bellamkonda and David Kane -->

```{r setup, include = FALSE}
library(learnr)
library(tutorial.helpers)
library(tidyverse)
library(babynames)
library(gghighlight)
library(gradethis)
library(tutorialExtras)

gradethis_setup()

knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 

x <- "n"

x1 <- c("one\ntwo", "one\ttwo", "\u00b5", "\U0001f604")

set.seed(9)

df <- tibble(name = c("Flora", "David", "Terra", NA))

df1 <- tibble(name = c("Flora", "David", "Terra", NA))

df2 <- tribble(
  ~ name, ~ fruit,
  "Carmen", "banana",
  "Carmen", "apple",
  "Marvin", "nectarine",
  "Terence", "cantaloupe",
  "Terence", "papaya",
  "Terence", "mandarin"
)

y <- c("Apple", "Banana", "Pear")

x2 <- "text\nEl Ni\xf1o was particularly bad this year"

x3 <- "text\n\x82\xb1\x82\xf1\x82\xc9\x82\xbf\x82\xcd"

u <- c("\u00fc", "u\u0308")

df <- tibble(x = c("1-1-1", "1-1-2", "1-3", "1-3-2", "1"))
```

```{r copy-code-chunk, child = system.file("child_documents/copy_button.Rmd", package = "tutorial.helpers")}
```


```{r, context = "server"}
grade_server("grade")
```

```{r Name}
question_text("Name:",
              answer_fn(function(value){
                              if(length(value) >= 1 ) {
                                return(mark_as(TRUE))
                                }
                              return(mark_as(FALSE) )
                              }),
              correct = "submitted",
              allow_retry = FALSE )
```

## Introduction
### 

This tutorial covers [Chapter 14: Strings](https://r4ds.hadley.nz/strings.html) from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. 
You will learn about some of the power of the [**stringr**](https://stringr.tidyverse.org/) package: how to create, combine, and extract strings, and about some of the challenges you might face with non-English strings. Some important functions which we will learn include:
[`str_c()`](https://stringr.tidyverse.org/reference/str_c.html),
[`str_glue()`](https://stringr.tidyverse.org/reference/str_glue.html),
[`str_flatten()`](https://stringr.tidyverse.org/reference/str_flatten.html),
[`separate_longer_delim()`](https://tidyr.tidyverse.org/reference/separate_longer_delim.html), and more.

## Creating a String
### 

We’ve created strings in passing earlier in the book but didn’t discuss the details. Firstly, you can create a string using either single quotes (') or double quotes (").

### Exercise 1

Type `this is a string` in double quotes and assign it to a variable named `str1` using `<-`.

```{r creating-a-string-1, exercise = TRUE}

```

```{r creating-a-string-1-hint-1, eval = FALSE}
str1 <- "..."
```

```{r creating-a-string-1-solution, exercise.reveal_solution = FALSE}
str1 <- "this is a string"
```

```{r creating-a-string-1-check}
grade_this_code()
```

### 

Now there’s no difference in behavior between the single quotes and double quotes, but in the interests of consistency, the [*Tidyverse*](https://style.tidyverse.org/syntax.html#character-vectors) style guide recommends using `"`, unless the string itself contains double quotes.

###

In the console, if you forget to close a quote, you’ll see `+`: the continuation prompt. If this happens to you and you can’t figure out which quote to close, press Escape to cancel and try again.

### Exercise 2

Assign the string `str2` to be `hello "world"`.

The code `"hello "world""` won't work in RStudio due to a syntax error. Without the proper escape character, RStudio will interpret the second double quote as the end of the string, resulting in a syntax error.

Instead use a single quote around the string.

```{r creating-a-string-2, exercise = TRUE}

```

```{r creating-a-string-2-hint-1, eval = FALSE}
str2 <- 'hello "world"'
```

```{r creating-a-string-2-solution, exercise.reveal_solution = FALSE}
str2 <- 'hello "world"'
```

```{r creating-a-string-2-check}
grade_this_code()
```

###

If you are including quotes within a string, use a single quote around the string. This way, the double quotes will be visible within the string.

### 

If you wanted to include single quotes in a string you could put the outer quotes as double quotes.

### Exercise 3

Now create a new variable `x` and set it `n` using `<-` in a string format using double quotes. Then on a new line call x.

```{r creating-a-string-3, exercise = TRUE}

```

```{r creating-a-string-3-hint-1, eval = FALSE}
x <- "n"
x
```

```{r creating-a-string-3-solution, exercise.reveal_solution = FALSE}
x <- "n"
x
```

```{r creating-a-string-3-check}
grade_this_code()
```

### 

R shows the whole string as a vector, which is why we don't see 'n' without quotes.

### Exercise 4

To view only the string and not the quotes, lets load the [`stringr`](https://stringr.tidyverse.org/) library using `library()`.

```{r creating-a-string-4, exercise = TRUE}

```

```{r creating-a-string-4-hint-1, eval = FALSE}
library(...)
```

```{r creating-a-string-4-solution, exercise.reveal_solution = FALSE}
library(stringr)
```

```{r creating-a-string-4-check}
grade_this_code()
```

### 

The **stringr** library is a part of the [*Tidyverse*](https://www.tidyverse.org/). We can just load the **tidyverse** library and the **stringr** library will be automatically loaded. 

### Exercise 5

To utilize the variable `x` that we previously set, let's type `str_view()` and specify `x` as the argument.

```{r creating-a-string-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r creating-a-string-5-hint-1, eval = FALSE}
str_view(...)
```

```{r creating-a-string-5-solution, exercise.reveal_solution = FALSE}
str_view(x)
```

```{r creating-a-string-5-check}
grade_this_code()
```

### 

The printed representation of a string is not the same as the string itself because the printed representation shows the escapes. To see the raw contents of the string, we use `str_view()`

### Exercise 6

To perform the same action with single quotes, let's create a new variable `y` and assign it the value `"'"` using the `<-` operator. Then, on a new line, type `str_view()` and pass `y` as the argument.

```{r creating-a-string-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r creating-a-string-6-hint-1, eval = FALSE}
y <- ...
str_view(...)
```

```{r creating-a-string-6-solution, exercise.reveal_solution = FALSE}
y <- "'"
str_view(y)
```

```{r creating-a-string-6-check}
grade_this_code()
```


### Exercise 7

There's another way to include quotes in a string. To include a literal single or double quote, you can use the backslash `\` to escape it. For example, `"\""` will return `'"'`.

Let's create a string with one single quote and assign it to the variable `single_quote`. Then, on a new line, type `str_view()` and pass `single_quote` as the argument.

```{r creating-a-string-7, exercise = TRUE}

```

```{r creating-a-string-7-hint-1, eval = FALSE}
single_quote <- '\''
str_view(...)
```

```{r creating-a-string-7-solution, exercise.reveal_solution = FALSE}
single_quote <- '\''
str_view(single_quote)
```

```{r creating-a-string-7-check}
grade_this_code()
```

### 

You might wonder what do you do if you wanted to include a literal backslash in your string. We'll see how in next exercise.

### Exercise 8

To include a literal backlash in your string, it is pretty simple and all you need to do is have two backslashes in a string to have one literal one. So just type two backslashes in a string and run it within `str_view()`.

```{r creating-a-string-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r creating-a-string-8-hint-1, eval = FALSE}
str_view("...")
```

```{r creating-a-string-8-solution, exercise.reveal_solution = FALSE}
str_view("\\")
```

```{r creating-a-string-8-check}
grade_this_code()
```

### Exercise 9

If you find yourself dealing with a complex situation where you have many backslashes and quotes to include, it can become confusing to keep track of them. 

To illustrate this problem, let's create a variable called tricky and set it to `""double_quote <- \"\\\"\" # or '\"'
single_quote <- '\\'' # or \"'\""`

```{r creating-a-string-9, exercise = TRUE}

```

```{r creating-a-string-9-hint-1, eval = FALSE}
tricky <- ...
```

```{r creating-a-string-9-solution, exercise.reveal_solution = FALSE}
tricky <- "double_quote <- \"\\\"\" # or '\"'
single_quote <- '\\'' # or \"'\""
```

```{r creating-a-string-9-check}
grade_this_code()
```

### 

That’s a lot of backslashes! (This is sometimes called [leaning toothpick syndrome](https://en.wikipedia.org/wiki/Leaning_toothpick_syndrome).)

### Exercise 10

Let's copy the previous code and then type `str_view()` with `tricky` set as the argument.

```{r creating-a-string-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r creating-a-string-10-hint-1, eval = FALSE}
tricky <- ...
str_view(tricky)
```

```{r creating-a-string-10-solution, exercise.reveal_solution = FALSE}
tricky <- "double_quote <- \"\\\"\" # or '\"'
single_quote <- '\\'' # or \"'\""
str_view(tricky)
```

```{r creating-a-string-10-check}
grade_this_code()
```

### 

After running the code, we should expect to see `double_quote <- "\"" # or '"' single_quote <- '\'' # or "'"` as the output. However, creating a string representation like this can be extremely confusing due to the excessive use of backslashes and quotes. In the next exercise, we will explore a solution to this problem.

### Exercise 11

Let's copy the previous code and modify tricky to be `r"(double_quote <- "\"" # or '"' single_quote <- '\'' # or "'")"`. Afterward, run `str_view()` with `tricky` as the argument.

With the updated string, which contains fewer quotes and backslashes, we might wonder if we will still obtain the same result as before.

```{r creating-a-string-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r creating-a-string-11-hint-1, eval = FALSE}
tricky <- ...
str_view(tricky)
```

```{r creating-a-string-11-solution, exercise.reveal_solution = FALSE}
tricky <- r"(double_quote <- "\"" # or '"' single_quote <- '\'' # or "'")"
str_view(tricky)
```

```{r creating-a-string-11-check}
grade_this_code()
```

### 

To solve the issue, we utilized a raw string, which is a specific type of string literal that doesn't interpret any special characters or escape sequences.

Typically, a raw string starts with `r"(, ends with )"`, and allows for any text representation. However, if the string contains )", alternatives like `r"[]"` or `r"{}"` can be used. Furthermore, you can add dashes to ensure unique opening and closing pairs, such as `r"--()--"`, `r"---()---"`, and so on. Raw strings offer flexibility to handle any text without problems.

### Exercise 12

Besides `\"`, `\'`, and `\\`, there are a few other special characters that can be useful. The most common ones are `\n` for a new line and `\t` for a tab.

Now let's observe how `str_view()` handles these special characters.

To do that, let's create a new variable called x1 and set it as a vector with the following elements: `"one\ntwo"`, `"one\ttwo"`, `"\u00b5"`, `"\U0001f604"`.

```{r creating-a-string-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r creating-a-string-12-hint-1, eval = FALSE}
x1 <- c(...)
```

```{r creating-a-string-12-solution, exercise.reveal_solution = FALSE}
x1 <- c("one\ntwo", "one\ttwo", "\u00b5", "\U0001f604")
```

```{r creating-a-string-12-check}
grade_this_code()
```

### 

If you want to check out a complete list of other special characters, check out in [Quotes](https://rdrr.io/r/base/Quotes.html).

### Exercise 13

Run `x1`.

```{r creating-a-string-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r creating-a-string-13-hint-1, eval = FALSE}
x1
```

```{r creating-a-string-13-solution, exercise.reveal_solution = FALSE}
x1
```

```{r creating-a-string-13-check}
grade_this_code()
```

### 

All we get is the same as what we types and dosen't actually take all the special characters that we put except the smiley face.

### Exercise 14

Now run `x1` with `str_view()` as the argument.

```{r creating-a-string-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r creating-a-string-14-hint-1, eval = FALSE}
str_view(x1)
```

```{r creating-a-string-14-solution, exercise.reveal_solution = FALSE}
str_view(x1)
```

```{r creating-a-string-14-check}
grade_this_code()
```

### 

Compared to just printing the strings in console, we actually see the spaces for the first string, we see a tab which shows that `str_view` can take in special characters.


## Creating many strings from data
### 

Now that you’ve learned the basics of creating a string or two by “hand”, we’ll go into the details of creating strings from other strings. This will help you solve the common problem where you have some text you wrote that you want to combine with strings from a data frame.

We’ll show you how to combine strings with `str_c()` and `str_glue()` and how you can use them with `mutate()`.
 
### Exercise 1

The first function we will learn is `str_c()`. 

`str_c()`takes any number of vectors as arguments and returns a character vector, so run `str_c("x","y")` and see what you get.

```{r creating-many-strings-from-dat-1, exercise = TRUE}

```

```{r creating-many-strings-from-dat-1-hint-1, eval = FALSE}
str_c(...,...)
```

```{r creating-many-strings-from-dat-1-solution, exercise.reveal_solution = FALSE}
str_c("x","y")
```

```{r creating-many-strings-from-dat-1-check}
grade_this_code()
```

### 

`str_c()` is a function in the `stringr` package in R that combines multiple character vectors into a single character vector. It is similar to the `paste()` function, but it uses `tidyverse` recycling and NA rules.



### Exercise 2

Copy previous code and change the argument to `str_c("Hello", c("Precptor","Anish"))` and run it.

```{r creating-many-strings-from-dat-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r creating-many-strings-from-dat-2-hint-1, eval = FALSE}
str_c(..., c(...))
```

```{r creating-many-strings-from-dat-2-solution, exercise.reveal_solution = FALSE}
str_c("Hello ", c("Precptor","Anish"))
```

```{r creating-many-strings-from-dat-2-check}
grade_this_code()
```

### 

Based from the result we can see that `str_c()` is vectorized, which means it can take multiple arguments and combine them element-wise. 
 
### Exercise 3

To demonstrate the usage of `str_c()` on a data set, let's create a tibble. Create a variable called `df` and assign it to `tibble(name = c("Flora", "Preceptor", "Terra", NA))`. This will generate a data set with string characters.

```{r creating-many-strings-from-dat-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r creating-many-strings-from-dat-3-hint-1, eval = FALSE}
... <- tibble(...=c(...))
```

```{r creating-many-strings-from-dat-3-solution, exercise.reveal_solution = FALSE}
df <- tibble(name = c("Flora", "Preceptor", "Terra", NA))
```

```{r creating-many-strings-from-dat-3-check}
grade_this_code()
```

### 

You might be wondering what tibble is, A tibble is a new form of a data frame in R that is part of the tidyverse library, and Tibbles print the data in a more efficient format than a data frame, showing the values of the columns, their datatype, and the size of the dataset.

### Exercise 4

Run `df` to see the data frame.

```{r creating-many-strings-from-dat-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r creating-many-strings-from-dat-4-hint-1, eval = FALSE}
...
```

```{r creating-many-strings-from-dat-4-solution, exercise.reveal_solution = FALSE}
df
```

```{r creating-many-strings-from-dat-4-check}
grade_this_code()
```

### 

the tibble has one column named "name." The first three rows contain the names "Flora," "David," and "Terra," respectively. However, the fourth row has an NA value, which typically represents missing or unknown data. 

### Exercise 5

Let's modify the tibble by first piping the tibble `df` to the `mutate()` function, then in `mutate()`, we will create new column `greeting` and set it equal to `str_c("Hi ", name, "!")`.

```{r creating-many-strings-from-dat-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r creating-many-strings-from-dat-5-hint-1, eval = FALSE}
... |>
  mutate(... = ...("...",name,"..."))
```

```{r creating-many-strings-from-dat-5-solution, exercise.reveal_solution = FALSE}
df |>
  mutate(greeting = str_c("Hi ", name, "!"))
```

```{r creating-many-strings-from-dat-5-check}
grade_this_code()
```

### 

After modifying the tibble, we still have a  column called `name`. We used the `mutate()` function from the ["dplyr"](https://dplyr.tidyverse.org/) package to create a new column called `greeting`. The `str_c()` function is used to concatenate the string "Hi " with the values in the `name` column. 

### Exercise 6

If you are mixing many fixed and variable strings with `str_c()`, you’ll notice that you type a lot of `"`s, making it hard to see the overall goal of the code. An alternative approach is provided by the glue package via `str_glue()`.

Let's create a variable named `df1` and set it to `tibble(name = c("Flora","Preceptor","Terra",NA))` which create a data set with the string characters.

```{r creating-many-strings-from-dat-6, exercise = TRUE}

```

```{r creating-many-strings-from-dat-6-hint-1, eval = FALSE}
... <- tibble(...=c(...))
```

```{r creating-many-strings-from-dat-6-solution, exercise.reveal_solution = FALSE}
df1 <- tibble(name = c("Flora","Preceptor","Terra",NA))
```

```{r creating-many-strings-from-dat-6-check}
grade_this_code()
```

### 

How `str_glue()` works is that if you give it a single string that has a special feature: anything inside `{}` will be evaluated like it’s outside of the quotes.

### Exercise 7

Let's modify the tibble by first piping the tibble `df1` to the `mutate()` function, then in `mutate()`, we will create new column `greeting` and set it equal to `str_glue("Hi {name} !")`.

```{r creating-many-strings-from-dat-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r creating-many-strings-from-dat-7-hint-1, eval = FALSE}
df1 |>
  ...(greeting = ...())
```

```{r creating-many-strings-from-dat-7-solution, exercise.reveal_solution = FALSE}
df1 |>
  mutate(greeting = str_glue("Hi {name} !"))
```

```{r creating-many-strings-from-dat-7-check}
grade_this_code()
```

### 

After modifying the tibble, we still have a  column called `name`. We used the `mutate()` function from the ["dplyr"](https://dplyr.tidyverse.org/) package to create a new column called `greeting`. As you can see, `str_glue()` currently converts missing values to the string "NA" unfortunately making it inconsistent with `str_c()`.

### Exercise 8

`str_c()` and `str_glue()` are suitable for use with `mutate()` since their output matches the length of their inputs. However, if you need a function that works well with `summarize()` and always returns a single string, `str_flatten()` comes into play. It takes a character vector as input and combines each element of the vector into a single string.

Type `str_flatten()` and within it have a vector of strings like this `c("x","y","z")`.

```{r creating-many-strings-from-dat-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r creating-many-strings-from-dat-8-hint-1, eval = FALSE}
str_flatten(...)
```

```{r creating-many-strings-from-dat-8-solution, exercise.reveal_solution = FALSE}
str_flatten(c("x","y","z"))
```

```{r creating-many-strings-from-dat-8-check}
grade_this_code()
```

### 

One variation of `str_flatten()` is `str_flatten_comma()` is a variation designed specifically for flattening with commas. It automatically recognizes if last uses the Oxford comma and handles the special case of 2 elements.

### Exercise 9

What if you want commas after every letter. Copy the previous code and within the argument, add a comma and type a comma in string like this `","`.

```{r creating-many-strings-from-dat-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r creating-many-strings-from-dat-9-hint-1, eval = FALSE}
str_flatten(c(...),...)
```

```{r creating-many-strings-from-dat-9-solution, exercise.reveal_solution = FALSE}
str_flatten(c("x","y","z"), ",")
```

```{r creating-many-strings-from-dat-9-check}
grade_this_code()
```

### 

The second argument which was a comma as a string as we saw, it is actually known as a `collapse`: a string to enter between each piece. Defaults to `""`.

### Exercise 10

Let's fix the grammar of the string we got in previous exercise, copy the previous code and add `last = ", and "`.

```{r creating-many-strings-from-dat-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r creating-many-strings-from-dat-10-hint-1, eval = FALSE}
str_flatten(c(...),..., last = ...)
```

```{r creating-many-strings-from-dat-10-solution, exercise.reveal_solution = FALSE}
str_flatten(c("x","y","z"), ",", last = ", and ")
```

```{r creating-many-strings-from-dat-10-check}
grade_this_code()
```

### 

The `last` argument is a optional string to use in place of the final separator.

### Exercise 11

Let's now use `str_flatten()` with `summarize()`. Run `df2` to have a quick look at the data frame.

```{r creating-many-strings-from-dat-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r creating-many-strings-from-dat-11-hint-1, eval = FALSE}
df2
```

```{r creating-many-strings-from-dat-11-solution, exercise.reveal_solution = FALSE}
df2
```

```{r creating-many-strings-from-dat-11-check}
grade_this_code()
```

### 

The tibble has two columns named "name" and "fruit". Carmen has more than one fruit to his name and Terence has more than two fruits to his name.

### Exercise 12

Start a pipe with `df2` to `summarize()` and within `summarize()`, type the column `fruit` and set it to `str_flatten(fruit, ", ")`. 

```{r creating-many-strings-from-dat-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r creating-many-strings-from-dat-12-hint-1, eval = FALSE}
df2 |>
  summarize(...)
```

```{r creating-many-strings-from-dat-12-solution, exercise.reveal_solution = FALSE}
df2 |>
  summarize(fruit = str_flatten(fruit, ", "))
```

```{r creating-many-strings-from-dat-12-check}
grade_this_code()
```

### 

`summarize()` creates a new data frame. It returns one row for each combination of grouping variables; if there are no grouping variables, the output will have a single row summarizing all observations in the input.

### Exercise 13

Within `summarize()` add `.by = name`.

```{r creating-many-strings-from-dat-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r creating-many-strings-from-dat-13-hint-1, eval = FALSE}
... |>
  summarize(...,.by = ...)
```

```{r creating-many-strings-from-dat-13-solution, exercise.reveal_solution = FALSE}
df2 |>
    summarize(fruit = str_flatten(fruit, ", "), .by = name)
```

```{r creating-many-strings-from-dat-13-check}
grade_this_code()
```

### 

The `.by` arguement is a selection of columns to group by for just this operation, functioning as an alternative to `group_by()`. For details and examples, see `?dplyr_by`.

The final outcome ensures the absence of duplicate names while effectively organizing all fruits based on their respective associations.

To review, `mutate()` either changes an existing column or adds a new one. `summarize()` calculates a single value (per group).

## Extracting data from strings
### 

It's very common for multiple variables to be crammed together into a single string. In this section, you’ll learn how to use four **tidyr** functions to extract them:

`df |> separate_longer_delim(col, delim)`
`df |> separate_longer_position(col, width)`
`df |> separate_wider_delim(col, delim, names)`
`df |> separate_wider_position(col, widths)`

### Exercise 1

Separating a string into rows tends to be most useful when the number of components varies from row to row. The most common case is requiring `separate_longer_delim()` to split based on a delimiter.

Create a new tibble using `tibble()`, create a column `x` and set it to be a vector which should look like `c("a,b,c", "d,e", "f")` and assign it to `df1`.

```{r extracting-data-from-strings-1, exercise = TRUE}

```

```{r extracting-data-from-strings-1-hint-1, eval = FALSE}
df1 <- tibble(... = c())
```

```{r extracting-data-from-strings-1-solution, exercise.reveal_solution = FALSE}
df1 <- tibble(x = c("a,b,c", "d,e", "f"))
```

```{r extracting-data-from-strings-1-check}
grade_this_code()
```

### 

Just like with `pivot_longer()` and `pivot_wider()`, `_longer` like `separate_longer_delim()` functions make the input data frame longer by creating new rows and `_wider` functions make the input data frame wider by generating new columns.

### Exercise 2

Copy the previous code and on a new line, start a pipe with `df1` to `separate_longer_delim()`. Within the function, type the column `x` and set `delim` equal to `","`.

```{r extracting-data-from-strings-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r extracting-data-from-strings-2-hint-1, eval = FALSE}
df1 <- ...
df1 |>
  separate_longer_delim(...,... = ",")
```

```{r extracting-data-from-strings-2-solution, exercise.reveal_solution = FALSE}
df1 <- tibble(x = c("a,b,c", "d,e", "f"))
df1 |>  
  separate_longer_delim(x,delim = ",")
```

```{r extracting-data-from-strings-2-check}
grade_this_code()
```

### 

If you are wondering what `delim = ","` is, the `delim = ","` parameter is used to specify the delimiter character in functions that involve reading or writing delimited data files.

For example, when reading a CSV (Comma-Separated Values) file using the `read_csv()` function from the "readr" or "tidyverse" package, you can specify `delim = ","` to indicate that the values in the file are separated by commas. 

### Exercise 3

Sometimes distinct numbers within a string are not separated by commas or spaces. In such cases, how should we properly split the string to separate these numbers? To demonstrate the issue create a new `tibble()`, set `x` as the name of the column and set `x` equal to a vector which looks like  `c("1211", "131", "21")` and lastly assign it to `df2`.

```{r extracting-data-from-strings-3, exercise = TRUE}

```

```{r extracting-data-from-strings-3-hint-1, eval = FALSE}
df2 <- tibble(... = c())
```

```{r extracting-data-from-strings-3-solution, exercise.reveal_solution = FALSE}
df2 <- tibble(x = c("1211", "131", "21"))
```

```{r extracting-data-from-strings-3-check}
grade_this_code()
```

### 

As you look at the tibble, notice we can't separate the numbers by commas to make the column longer. That's where `separate_longer_position()` comes into the play.


### Exercise 4

Copy the previous code and then, on a new line, pipe with `df2` to `separate_longer_position()`, within the function, type the column `x` and then set the `width` to 1.

```{r extracting-data-from-strings-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r extracting-data-from-strings-4-hint-1, eval = FALSE}
df2 <- tibble(... = c())
df2 |>
  separate_longer_position(x, ... = ...)
```

```{r extracting-data-from-strings-4-solution, exercise.reveal_solution = FALSE}
df2 <- tibble(x = c("1211", "131", "21"))
df2 |> 
  separate_longer_position(x, width = 1)
```

```{r extracting-data-from-strings-4-check}
grade_this_code()
```

### 

Now you see that all the strings have been separated into one-digit integers, creating more rows to fit each integer into each row.

In R, the `width = 1` parameter is used in functions that involve writing or formatting output to specify the width of the output field.

### Exercise 5

What if you want to create columns when separating?
Separating a string into columns tends to be most useful when there are a fixed number of components in each string, and you want to spread them into columns. They are slightly more complicated than their longer equivalents because you need to name the columns.

Create a `tibble()`, set `x` as the name of the column and set `x` equal to a vector which looks like  `c("a10.1.2022", "b10.2.2011", "e15.1.2015")` and lastly assign it to `df3`.

```{r extracting-data-from-strings-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r extracting-data-from-strings-5-hint-1, eval = FALSE}
df3 <- tibble(x = c(...))
```

```{r extracting-data-from-strings-5-solution, exercise.reveal_solution = FALSE}
df3 <- tibble(x = c("a10.1.2022", "b10.2.2011", "e15.1.2015"))
```

```{r extracting-data-from-strings-5-check}
grade_this_code()
```

### 

In this following data set, x is made up of a code, an edition number, and a year, separated by `"."`. To use `separate_wider_delim()`, we supply the delimiter and the names in two arguments.

### Exercise 6

Copy the previous code and start pipe with `df3` to `separate_wider_delim()`, within the function, type `x`, then set the `delim` to `"."` and finally set the `names` to a vector which looks like ` c("code", "edition", "year")`.

```{r extracting-data-from-strings-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r extracting-data-from-strings-6-hint-1, eval = FALSE}
df3 <- tibble(x = c(...))
df3 |> 
  ....(
    x,
    .... = ".",
    names = c(...)
  )
```

```{r extracting-data-from-strings-6-solution, exercise.reveal_solution = FALSE}
df3 <- tibble(x = c("a10.1.2022", "b10.2.2011", "e15.1.2015"))

df3 |> 
  separate_wider_delim(
  x,
  delim = ".",
  names = c("code", "Edition", "year"))
```

```{r extracting-data-from-strings-6-check}
grade_this_code()
```

### 

What if I don't care about the edition of the book and want to delete it?

### Exercise 7

If you don't want a column, all we have to do rename to column to be `NA`. Copy the previous code and change `edition` in names to `NA`.

```{r extracting-data-from-strings-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r extracting-data-from-strings-7-hint-1, eval = FALSE}
df3 <- tibble(x = c(...))
df3 |> 
  ....(
    x,
    .... = ".",
    names = c(...)
  )
```

```{r extracting-data-from-strings-7-solution, exercise.reveal_solution = FALSE}
df3 <- tibble(x = c("a10.1.2022", "b10.2.2011", "e15.1.2015"))
df3 |> 
  separate_wider_delim(
  x,
  delim = ".",
  names = c("code", NA, "year"))
```

```{r extracting-data-from-strings-7-check}
grade_this_code()
```

### Exercise 8

What if you want to separate them by different width in position? `separate_wider_position()` is the function that solves that.

Create a `tibble()`, set `x` as the name of the column and set `x` equal to a vector which looks like  `c("202215TX", "202122LA", "202325CA")` and lastly assign it to `df4`.

```{r extracting-data-from-strings-8, exercise = TRUE}

```

```{r extracting-data-from-strings-8-hint-1, eval = FALSE}
df4 <- tibble(x = c(...))
```

```{r extracting-data-from-strings-8-solution, exercise.reveal_solution = FALSE}
df4 <- tibble(x = c("202215TX", "202122LA", "202325CA"))
```

```{r extracting-data-from-strings-8-check}
grade_this_code()
```
### 

`separate_wider_position()` works a little differently because you typically want to specify the width of each column. So you give it a named integer vector, where the name gives the name of the new column, and the value is the number of characters it occupies. You can omit values from the output by not naming them

### Exercise 9

Copy the previous code and start a pipe with `df4` to `separate_wider_position()`, within the function, type `x`, then set the `widths` to  a vector which looks like ` c(year = 4, age = 2, state = 2)`.

```{r extracting-data-from-strings-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r extracting-data-from-strings-9-hint-1, eval = FALSE}
df4 <- tibble(x = c(...))
... |> 
  ...(
    x,
    widths = c(...,...,...)
  )
```

```{r extracting-data-from-strings-9-solution, exercise.reveal_solution = FALSE}
df4 <- tibble(x = c("202215TX", "202122LA", "202325CA"))
df4 |>  
  separate_wider_position(
  x, 
  widths = c(year = 4, age = 2, state = 2)
  )
```

```{r extracting-data-from-strings-9-check}
grade_this_code()
```

### 

`_wider` functions like the one we used above make the input data frame wider by generating new columns.

### Exercise 10

`separate_wider_delim()` requires a fixed and known set of columns. What happens if some of the rows don’t have the expected number of pieces?

Create a `tibble()`, set `x` as the name of the column and set `x` equal to a vector which looks like  `c("1-1-1", "1-1-2", "1-3", "1-3-2", "1")` and lastly assign it to `df`.


```{r extracting-data-from-strings-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r extracting-data-from-strings-10-hint-1, eval = FALSE}
df <- tibble(x = c(...))
```

```{r extracting-data-from-strings-10-solution, exercise.reveal_solution = FALSE}
df <- tibble(x = c("1-1-1", "1-1-2", "1-3", "1-3-2", "1"))
```

```{r extracting-data-from-strings-10-check}
grade_this_code()
```

### 

In response to not having the same number of pieces, there are two possible problems, too few or too many pieces, so `separate_wider_delim()` provides two arguments to help: `too_few` and `too_many`.

### Exercise 11

Try running the following code chunk. You’ll notice that we get an error, but the error gives us some suggestions on how you might proceed. Let’s start by debugging the problem.

Within `separate_wider_delim()` add the argument `too_few` to be `"debug"`. Assign this code to a variable `debug`. At the end on a new line call `debug` to print the result.

```{r extracting-data-from-strings-11, exercise = TRUE}
df <- tibble(x = c("1-1-1", "1-1-2", "1-3", "1-3-2", "1"))
df |>
  separate_wider_delim(
    x,
    delim = "-",
    names = c("x", "y", "z")
  )
```

```{r extracting-data-from-strings-11-hint-1, eval = FALSE}
df <- tibble(x = c("1-1-1", "1-1-2", "1-3", "1-3-2", "1"))
debug <- ... |> 
  separate_wider_delim(
    x,
    ... = "-",
    ... = c("x", "y", "z"),
    too_few = ...
  )
...
```

```{r extracting-data-from-strings-11-solution, exercise.reveal_solution = FALSE}
df <- tibble(x = c("1-1-1", "1-1-2", "1-3", "1-3-2", "1"))
debug <- df |>  
  separate_wider_delim(
    x, 
    delim = "-",
    names = c("x", "y", "z"),
    too_few = "debug"
  )
debug
```

```{r extracting-data-from-strings-11-check}
grade_this_code()
```

### 

When you use the debug mode, you get three extra columns added to the output: `x_ok`, `x_pieces`, and `x_remainder` (if you separate a variable with a different name, you’ll get a different prefix).

`x_pieces` tells us how many pieces were found, compared to the expected 3 (the length of names). `x_remainder` isn’t useful when there are too few pieces, but we’ll see it again shortly

### Exercise 12

In other cases, you may want to fill in the missing pieces with `NA`s and move on. That’s the job of `too_few` = `"align_start"` and `too_few` = `"align_end"` which allow you to control where the `NA`s should go.

Copy the previous code and change `too_few` to be set to `"align_start"`.

```{r extracting-data-from-strings-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r extracting-data-from-strings-12-hint-1, eval = FALSE}
df <- tibble(x = c("1-1-1", "1-1-2", "1-3", "1-3-2", "1"))
debug <- ... |> 
  separate_wider_delim(
    x,
    ... = "-",
    ... = c("x", "y", "z"),
    too_few = ...
  )
debug
```

```{r extracting-data-from-strings-12-solution, exercise.reveal_solution = FALSE}
df <- tibble(x = c("1-1-1", "1-1-2", "1-3", "1-3-2", "1"))
debug <- df |>  
  separate_wider_delim(
    x, 
    delim = "-",
    names = c("x", "y", "z"),
    too_few = "align_start"
  )
debug
```

```{r extracting-data-from-strings-12-check}
grade_this_code()
```

### 

You see that some of columns are filled with `NA` since we put `too_few = "align_start"`.

### Exercise 13

The same principles apply if you have too many pieces.

Consider a `tibble()` named `df`, with a variable `x` set equal to a vector `c("1-1-1", "1-1-2", "1-3-5-6", "1-3-2", "1-3-5-7-9")`.

Try running the following code chunk. You will get an error and get suggestions to use `too_many = "debug"` or `too_many = "drop/merge"`. We will use "debug" to see what being kept and what's being left and after that we will talk about use drop and merge.


Within `separate_wider_delim()` add the argument `too_many` to be `"debug"`.

```{r extracting-data-from-strings-13, exercise = TRUE}
df <- tibble(x = c("1-1-1", "1-1-2", "1-3-5-6", "1-3-2", "1-3-5-7-9"))
df |>
  separate_wider_delim(
    x,
    delim = "-",
    names = c("x", "y", "z")
  )
```

```{r extracting-data-from-strings-13-hint-1, eval = FALSE}
df <- tibble(x = ...)
... |> 
  separate_wider_delim(
    ...,
    delim = "...",
    names = c(...),
    too_many = "..."
  )
```

```{r extracting-data-from-strings-13-solution, exercise.reveal_solution = FALSE}
df <- tibble(x = c("1-1-1", "1-1-2", "1-3-5-6", "1-3-2", "1-3-5-7-9"))
df |>  
  separate_wider_delim(
    x, 
    delim = "-",
    names = c("x", "y", "z"),
    too_many = "debug"
  )
```

```{r extracting-data-from-strings-13-check}
grade_this_code()
```

### 

When we debug the result, you can see the purpose of `x_remainder`: it shows what was left behind and not inserted into the columns.

### Exercise 14

Copy the previous code and change `too_many` to "drop".

```{r extracting-data-from-strings-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r extracting-data-from-strings-14-hint-1, eval = FALSE}
df <- tibble(x = ...)
... |> 
  separate_wider_delim(
    ...,
    delim = "...",
    names = c(...),
    too_many = "..."
  )
```

```{r extracting-data-from-strings-14-solution, exercise.reveal_solution = FALSE}
df <- tibble(x = c("1-1-1", "1-1-2", "1-3-5-6", "1-3-2", "1-3-5-7-9"))
df |>  
  separate_wider_delim(
    x, 
    delim = "-",
    names = c("x", "y", "z"),
    too_many = "drop"
  )
```

```{r extracting-data-from-strings-14-check}
grade_this_code()
```

### 

As we are already aware by the word `drop`, it has been established that Rstudio will discard the remaining x remainders.

### Exercise 15

Copy previous and now change `too_many` to "merge".

```{r extracting-data-from-strings-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r extracting-data-from-strings-15-hint-1, eval = FALSE}
df <- tibble(x = ...)
... |> 
  separate_wider_delim(
    ...,
    delim = "...",
    names = c(...),
    too_many = "..."
  )
```

```{r extracting-data-from-strings-15-solution, exercise.reveal_solution = FALSE}
df <- tibble(x = c("1-1-1", "1-1-2", "1-3-5-6", "1-3-2", "1-3-5-7-9"))
df |>  
  separate_wider_delim(
    x, 
    delim = "-",
    names = c("x", "y", "z"),
    too_many = "merge"
  )
```

```{r extracting-data-from-strings-15-check}
grade_this_code()
```

### 

The `x remainders` are merged into the final column.


## Letters
### 

In this section, we’ll introduce you to functions that allow you to work with the individual letters within a string. You’ll learn how to find the length of a string, extract sub strings, and handle long strings in plots and tables.

### Exercise 1

How do you find length of a string? That's where `str_length()` comes into play. `str_length()` tells you the number of letters in the string.

Type the function `str_length()` and type `"hello world"` as the argument and run it.

```{r letters-1, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r letters-1-hint-1, eval = FALSE}
str_length(...)
```

```{r letters-1-solution, exercise.reveal_solution = FALSE}
str_length("hello world")
```

```{r letters-1-check}
grade_this_code()
```

### 

`str_length()` not only counts the letters but also the spaces in between the words in a string. If you want to explore more, check out [`str_length()`](https://stringr.tidyverse.org/reference/str_length.html).

### Exercise 2

In addition to `"hello world"` in `str_length()`, add two more values which are `"programming"` and `NA`. Make sure to put these three string in vector like `c(...,...,...)`.

```{r letters-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r letters-2-hint-1, eval = FALSE}
str_length(c(...,...,...))
```

```{r letters-2-solution, exercise.reveal_solution = FALSE}
str_length(c("hello world", "programming", NA))
```

```{r letters-2-check}
grade_this_code()
```

### 

The values you'll get are 11, 11 and NA. 

### Exercise 3

Let's load the `babynames` package using `library()`.

```{r letters-3, exercise = TRUE}

```

```{r letters-3-hint-1, eval = FALSE}
...
```

```{r letters-3-solution, exercise.reveal_solution = FALSE}
library(babynames)
```

```{r letters-3-check}
grade_this_code()
```

### 

The "babynames" package contains a data set called `babynames` which contained names used for babies from 1880 to 2017. If you want to explore the data set, checkout [popular baby names](https://www.ssa.gov/oact/babynames/limits.html).

### Exercise 4

Run `babynames` to have an overview of the data set.

```{r letters-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r letters-4-hint-1, eval = FALSE}
babynames
```

```{r letters-4-solution, exercise.reveal_solution = FALSE}
babynames
```

```{r letters-4-check}
grade_this_code()
```

### 

We have five columns(year, sex, name, n, prop). The `n` means the count of the name and the `prop` is the proportion or fraction of individuals with that name out of the total number of individuals.

### Exercise 5

To discover some findings lets use this with `count()` to find the distribution of lengths of US baby names. 

Start a pipe with babynames to `count()`.

```{r letters-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r letters-5-hint-1, eval = FALSE}
... |>
  count()
```

```{r letters-5-solution, exercise.reveal_solution = FALSE}
babynames |>  
  count()
```

```{r letters-5-check}
grade_this_code()
```

### 

We see that there are a total count of 1924665 names used. Let's make the function more complex to find the distribution of lengths of baby names.

### Exercise 6

Let's create two columns to see the length of the name and also the count. Within `count()` type `length` and set it equal to `str_length(name)` and then type `wt` and set it to `n`.

```{r letters-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r letters-6-hint-1, eval = FALSE}
... |>
  count(... = str_length(...),wt = ...)
```

```{r letters-6-solution, exercise.reveal_solution = FALSE}
babynames |>  
  count(
    length = str_length(name),
    wt = n
  )
```

```{r letters-6-check}
grade_this_code()
```

### 

What `wt = n` does is that it specifies that the count (n) should be used as the weight for the calculation. Looking at the results, we see that the biggest name contains 15 letters.

### Exercise 7

Now that we know that the longest name is 15 letters. Let's find the most famous names which are 15 letters. Start a pipe with `babynames` to `filter()`. We have to select the names which are 15 letters so type `str_length(name)` and set it to be equal to be 15 using `==`. 

```{r letters-7, exercise = TRUE}

```

```{r letters-7-hint-1, eval = FALSE}
... |>
  filter(...(name)== 15)
```

```{r letters-7-solution, exercise.reveal_solution = FALSE}
babynames |> 
  filter(
    str_length(name) == 15
  )
```

```{r letters-7-check}
grade_this_code()
```

### 

In RStudio, the `==` operator is used to test for equality between two values. It is a comparison operator that returns a logical value of TRUE if the values are equal and FALSE otherwise. 


### Exercise 8

Now that we have all the names with 15 letters, let's continue the pipe from `filter()` to `count()`. Within `count()` type `name`, set `wt` to `n` and then set `sort` to TRUE.

```{r letters-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r letters-8-hint-1, eval = FALSE}
... |>
  ...|>
  count(..., wt = ..., sort = ...)
```

```{r letters-8-solution, exercise.reveal_solution = FALSE}
babynames |> 
  filter(
    str_length(name) == 15
  ) |> 
  count(
    name, 
    wt = n, 
    sort = TRUE
  )
```

```{r letters-8-check}
grade_this_code()
```

### 

Looks at the results, the most famous name is Francisco Javier, being used 123 times. Looking at the other names, Christopher looks similar is most of the other names.

### Exercise 9

Now that we have learned `str_length()`. Let's move on to learning about `str_sub()`. 

Create a variable `y` and set it equal to a vector containing strings: Apple, Banana, and Pear.

```{r letters-9, exercise = TRUE}

```

```{r letters-9-hint-1, eval = FALSE}
y <- c(...,...,...)
```

```{r letters-9-solution, exercise.reveal_solution = FALSE}
y <- c("Apple", "Banana", "Pear")
```

```{r letters-9-check}
grade_this_code()
```

### 

You can extract parts of a string using `str_sub(string, start, end)`, where start and end are the positions where the substring should start and end. 

### Exercise 10

To extract a substring using the `str_sub()` function, specify the following arguments: the first argument should be the variable `y` that we have defined, the second argument should be the starting position (1 in this case), and the third argument should be the ending position (3 in this case).

```{r letters-10, exercise = TRUE}

```

```{r letters-10-hint-1, eval = FALSE}
str_sub(y, ...,...)
```

```{r letters-10-solution, exercise.reveal_solution = FALSE}
str_sub(y, 1, 3)
```

```{r letters-10-check}
grade_this_code()
```

### 

Looking at results, when using `str_sub()`The start and end arguments are inclusive, so the length of the returned string will be end - start + 1

### Exercise 11

Let's modify the line from previous code and change the 2nd arguement to `-3` and the 3rd argument to `-1`.

```{r letters-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r letters-11-hint-1, eval = FALSE}
str_sub(..., ...,...)
```

```{r letters-11-solution, exercise.reveal_solution = FALSE}
str_sub(y, -3, -1)
```

```{r letters-11-check}
grade_this_code()
```

### 

If you want to look at the end of the string, you can use negative values to count back from the end of the string: -1 is the last character, -2 is the second to last character, etc.

### Exercise 12

You might ask what if the range is bigger than the actual string? Let's see then, type `str_sub()` and in the first argument type "a", then type `1` for 2nd arguemtn and `5` for 3rd arguemnt.

```{r letters-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r letters-12-hint-1, eval = FALSE}
str_sub("...",1,...)
```

```{r letters-12-solution, exercise.reveal_solution = FALSE}
str_sub("a", 1, 5)
```

```{r letters-12-check}
grade_this_code()
```

### 

Seeing the results, we have to note that `str_sub()` won’t fail if the string is too short: it will just return as much as possible

### Exercise 13

Now's that we have a sense of `str_sub()`, let's find the first and last letter of each name.
Start a pipe with `babynames` to `mutate()`.

Within `mutate()`, create a new column called `first` and set it to `str_sub(name, 1,1)` to get the first letter. 

```{r letters-13, exercise = TRUE}

```

```{r letters-13-hint-1, eval = FALSE}
... |>
  ...(... = str_...(name,1,...))
```

```{r letters-13-solution, exercise.reveal_solution = FALSE}
babynames |>
  mutate(
    first = str_sub(name, 1,1)
  )
```

```{r letters-13-check}
grade_this_code()
```

### 

If you didnt know, In Python, indexing starts from zero, whereas in RStudio, indexing starts from one, resulting in a slight variation in accessing elements and slicing sequences.

### Exercise 14

In addition to creating the `first` column , let's add the `last` column. Within `mutate()`, add `last` and set it to `str_sub(name, -1,-1)`.

```{r letters-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r letters-14-hint-1, eval = FALSE}
... |>
  ...(... = str_...(name,1,...),
      last = ..._sub(name, -1,-1))
```

```{r letters-14-solution, exercise.reveal_solution = FALSE}
babynames |>
  mutate(
    first = str_sub(name, 1,1),
    last = str_sub(name, -1,-1)
  )
```

```{r letters-14-check}
grade_this_code()
```

### 

When we ran the code, we see two new columns `first` and `last` which show the first and last letters of a name.



## Summary
### 

This tutorial covered [Chapter 14: Strings](https://r4ds.hadley.nz/strings.html) from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. 
You learned about some of the power of the [**stringr**](https://stringr.tidyverse.org/) package: how to create, combine, and extract strings, and about some of the challenges you might face with non-English strings. Some important functions which we learned include:
[`str_c()`](https://stringr.tidyverse.org/reference/str_c.html),
[`str_glue()`](https://stringr.tidyverse.org/reference/str_glue.html),
[`str_flatten()`](https://stringr.tidyverse.org/reference/str_flatten.html),
[`separate_longer_delim()`](https://tidyr.tidyverse.org/reference/separate_longer_delim.html), and more.



Once you are finished:

-   Click the 'Download Grade' button below. This will download an html document of your grade summary.
-   Submit the downloaded html to your learning management system.

```{r}
grade_print_ui("grade")
```

## Check Grade

```{r}
grade_button_ui(id = "grade")
```