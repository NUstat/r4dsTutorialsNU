---
title: Data import
tutorial:
  id: data-import
output:
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
    css: ["css/nu-theme.css"]
runtime: shiny_prerendered
description: 'Tutorial for Chapter 7: Data import'
---

<!-- Modification of r4ds.tutorials author: David Kane -->

```{r setup, include = FALSE}
library(learnr)
library(tutorial.helpers)
library(tidyverse)
library(janitor)
library(gradethis)
library(tutorialExtras)

gradethis_setup()

knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 

students <- read_csv("data/students.csv")

students2 <- students |> 
  clean_names() |> 
  mutate(
    meal_plan = factor(meal_plan),
    age = if_else(age == "five", "5", age),
    age = parse_number(age)
  )


# For creating this file once.
# write_csv(students2, "data/students2.csv") 
#write_rds(students2, "inst/tutorials/07-data-import/data/students2.rds")

simple_csv <- "
  x
  10
  .
  20
  30"

another_csv <- "
x,y,z
1,2,3"

tbl_1 <- tibble(John = 1 , Aliya = 2, Maxilla = 3)
```

```{r copy-code-chunk, child = system.file("child_documents/copy_button.Rmd", package = "tutorial.helpers")}
```

```{r, context = "server"}
grade_server("grade")
```

```{r Name}
question_text("Name:",
              answer_fn(function(value){
                              if(length(value) >= 1 ) {
                                return(mark_as(TRUE))
                                }
                              return(mark_as(FALSE) )
                              }),
              correct = "submitted",
              allow_retry = FALSE )
```

```{r}
grade_button_ui(id = "grade")
```

## Introduction
### 

This tutorial covers [Chapter 7: Data import](https://r4ds.hadley.nz/data-import.html) from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. You will learn how to import data into your R project using [`read_csv()`](https://readr.tidyverse.org/reference/read_delim.html) and related functions from the [**readr**](https://readr.tidyverse.org/) package. You will also learn how to write out data to files with functions like [`write_csv()`](https://readr.tidyverse.org/reference/write_delim.html).


## Reading data from a file
### 

This section provides practical advice for handling features like column names, types, and missing data. 

Note the distinction between *Tidyverse* (capitalized and in italics) and **tidyverse** (no capitalization and in bold). The latter refers to an actual R package, the one which we use almost every time we use R. The latter has a more [general meaning](https://www.tidyverse.org/):

> The tidyverse is an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures.


### Exercise 1

[**readr**](https://readr.tidyverse.org/) is the key package for reading in data. Load **readr** by typing `library(readr)` at your Console. Then run `help(package = "readr")`. Copy/paste the first header below. (It should be a single line which references the version number.)

```{r reading-data-from-a-file-1-q}
question_text(NULL,
        answer_fn(function(value){
            if (str_remove_all(str_to_lower(value), " ") %in% 
                c("documentationforpackage‘readr’version2.1.5")) {
                 return(mark_as(TRUE))}
                 return(mark_as(FALSE) ) }),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 1)
```

### 

Because **readr** is one of the core packages in the *Tidyverse* we rarely load it directly. Instead, we run `library(tidyverse)` which loads all those packages.

The "core" *Tidyverse* is the 9 packages loaded by `library(tidyverse)` but the broader *Tidyverse* universe includes [many more packages](https://www.tidyverse.org/packages/) which share the same general philosophy.

### Exercise 2

Consider this data:

```{r message = FALSE, comment = ''}
read_lines("data/students.csv") |> cat(sep = "\n")
```

### 

Write code for reading this data into R. Use `read_csv()` and set the `file` argument to `"data/students.csv"`. All the files we will use in this tutorial live in the `data/` directory.

```{r reading-data-from-a-file-2, exercise = TRUE}

```

```{r reading-data-from-a-file-2-hint-1, eval = FALSE}
read_csv(file = ...)
```

```{r reading-data-from-a-file-2-solution, exercise.reveal_solution = FALSE}
read_csv(file = "data/students.csv")
```

```{r reading-data-from-a-file-2-check}
grade_this({
  # custom checking code appears here
  if (identical(TRUE, all.equal(.result, .solution))) {
    pass(random_praise())
  }
  fail("Try Again!")
})
```

### 

When you run `read_csv()`, it prints out a message telling you the number of rows and columns of data, the delimiter that was used, and the column specifications (names of columns organized by the type of data the column contains). It also prints out some information about retrieving the full column specification and how to quiet this message. 

### Exercise 3

Instead of just reading in the file and then just "dumping" out the results back to the screen, run the same code as above but assign the result to a new object, `students`.


```{r reading-data-from-a-file-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-a-file-3-hint-1, eval = FALSE}
students <- read_csv(file = ...)
```

```{r reading-data-from-a-file-3-solution, exercise.reveal_solution = FALSE}
students <- read_csv(file = "data/students.csv")
```

```{r reading-data-from-a-file-3-check}
grade_this_code()
```

### 

There are two primary modes of doing data analysis. In the first, we write a series of statements, connected with pipes, which "dump out" their results directly to the screen. This approach is useful for interactive analysis. In the second, which usually comes later, we assign the results of the commands to an object, like `students`, which we will work with later.

### Exercise 4

Copy the previous code and on the next line print out the `students` object using the `print()` function.

```{r reading-data-from-a-file-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-a-file-4-hint-1, eval = FALSE}
students <- read_csv(file = "data/students.csv")
print(students)
```

```{r reading-data-from-a-file-4-solution, exercise.reveal_solution = FALSE}
students <- read_csv(file = "data/students.csv")
print(students)
```

```{r reading-data-from-a-file-4-check}
grade_this_code()
```

### 

In the `favourite.food` column, there are a bunch of food items, and then the character string `"N/A"`, which should have been a real `NA` that R will recognize as “not available”. This is something we can address using the `na` argument. 

###

Note we are explicitly using the `print()` function simply because of the way data is printed within the tutorial it is easier to observe variable names and types. In R, you could print the data with or without using the `print()` function.

### Exercise 5

By default, `read_csv()` only recognizes empty strings (`""`) in this dataset as NAs. We want it to also recognize the character string `"N/A"`. 

###

Modify the code from the previous exercise as follows: within the `read_csv()` function add the `na` argument and set it equal to `c("N/A", "")`.

```{r reading-data-from-a-file-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-a-file-5-hint-1, eval = FALSE}
students <- read_csv(file = "data/students.csv", na = ...)
print(students)
```

```{r reading-data-from-a-file-5-solution, exercise.reveal_solution = FALSE}
students <- read_csv(file = "data/students.csv", na = c("N/A", ""))
print(students)
```

```{r reading-data-from-a-file-5-check}
grade_this_code()
```

### 

There are a bewildering set of characters that different people will use to indicate that data is missing. Look carefully at your data to find them all.

### Exercise 6

You might also notice that the Student ID and Full Name columns are surrounded by backticks. That’s because they contain spaces, breaking R’s usual rules for variable names; they’re *non-syntactic* names. To refer to these variables, you need to surround them with backticks: `` ` ``. 

###

We could use the `rename()` function to turn these *non-syntactic* names into a more appropriate snake case format.

###

However sometimes, a data set will have several weirdly named variables. In that case, we recommend using `clean_names()` from the [**janitor**](https://sfirke.github.io/janitor/) package.

**janitor** has several useful functions, including `make_clean_names()`, which does the same thing as `clean_names()` but can be used directly during data import rather than as part of a pipe.

### 

The **janitor** package also has a function called `remove_empty()` to remove empty spaces, `remove_constant()` to remove columns of constant values, and many more. 

###

Pipe `students` to `janitor::clean_names()`. By including the package name directly before the function name, we do not have to directly load the `janitor` package.

```{r reading-data-from-a-file-6, exercise = TRUE}

```

```{r reading-data-from-a-file-6-hint-1, eval = FALSE}
students |> 
  janitor::clean_names()
```

```{r reading-data-from-a-file-6-solution, exercise.reveal_solution = FALSE}
students |> 
  janitor::clean_names()
```

```{r reading-data-from-a-file-6-check}
grade_this_code()
```

### 

`clean_names()` not only fixes the *non-syntactic* names like `Full Name`; it also cleans up any variable name which does not follow the standard approach of, first, no capitalization and, second, using underscores as a word seperator. Note how `favourite.food` becomes `favourite_food` and `mealPlan` becomes `meal_plan`


### Exercise 7

Another common task after reading in data is to consider variable types. For example, `meal_plan` is a categorical variable with a known set of possible values, which in R should be represented as a factor. Continue the pipe by adding a call to `mutate()`, with `meal_plan = factor(meal_plan)`.

```{r reading-data-from-a-file-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-a-file-7-hint-1, eval = FALSE}
students |> 
  janitor::clean_names() |> 
  mutate(meal_plan = ...(meal_plan))
```

```{r reading-data-from-a-file-7-solution, exercise.reveal_solution = FALSE}

# with namespacing ----
students |> 
  janitor::clean_names() |> 
  mutate(meal_plan = factor(meal_plan))


# without namespacing ----
students |> 
  clean_names() |> 
  mutate(meal_plan = factor(meal_plan))
```

```{r reading-data-from-a-file-7-check}
grade_this_code()
```

### 

Note that the values in the `meal_plan` variable have stayed the same, but the type of variable denoted underneath the variable name has changed from character (`<chr>`) to factor (`<fct>`).


### Exercise 8

Before you analyze these data, you’ll probably want to fix the `age` column. Currently, `age` is a character variable because one of the observations is typed out as `five` instead of a numeric `5`. 

Modify the previous code by re-defining `age` as `age = if_else(age == "five", "5", age)`. This should be done within the `mutate()` that is currently in the code. 

```{r reading-data-from-a-file-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-a-file-8-hint-1, eval = FALSE}
students |> 
  janitor::clean_names() |> 
  mutate(
    meal_plan = factor(meal_plan),
    age = ...(age == "five", "5", age)
  )
```

```{r reading-data-from-a-file-8-solution, exercise.reveal_solution = FALSE}
# with namespacing ----
students |> 
  janitor::clean_names() |> 
  mutate(
    meal_plan = factor(meal_plan),
    age = if_else(age == "five", "5", age)
  )


# without namespacing ----
students |> 
  clean_names() |> 
  mutate(
    meal_plan = factor(meal_plan),
    age = if_else(age == "five", "5", age)
  )
```

```{r reading-data-from-a-file-8-check}
grade_this_code()
```

### 

A new function here is `if_else()`, which has three arguments. The first argument `test` should be a logical vector. The result will contain the value of the second argument, `yes`, when test is `TRUE`, and the value of the third argument, `no`, when it is `FALSE`. Here we’re saying if `age` is the character string `"five"`, make it `5`, and if not leave it as `age`. 

### Exercise 9

The result of the pipe still shows `age` as a character variable. But we know that `age` is a number. R has a collection of `parse_*` functions which transform variable types. Continue the data wrangling by adding a third line to the `mutate()` statement: `age = parse_number(age)`. Don't forget to separate the different `mutate()` steps with commas.  

```{r reading-data-from-a-file-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-a-file-9-hint-1, eval = FALSE}
students |> 
  janitor::clean_names() |> 
  mutate(
    meal_plan = factor(meal_plan),
    age = if_else(age == "five", "5", age),
    age = ...(age)
  )
```

```{r reading-data-from-a-file-9-solution, exercise.reveal_solution = FALSE}
# with namespacing ----
students |> 
  janitor::clean_names() |> 
  mutate(
    meal_plan = factor(meal_plan),
    age = if_else(age == "five", "5", age),
    age = parse_number(age)
  )


# without namespacing ----
students |> 
  clean_names() |> 
  mutate(
    meal_plan = factor(meal_plan),
    age = if_else(age == "five", "5", age),
    age = parse_number(age)
  )
```

```{r reading-data-from-a-file-9-check}
grade_this_code()
```

### 

We could combine the two manipulations of `age` into a single line within `mutate()` as:

> `age = parse_number(if_else(age == "five", "5", age))`

But it is often easier to build a pipe step-by-step, checking that each part is doing what you want before moving on.


### Exercise 10

"CSV" stands for **c**omma-**s**eparated **v**alues, meaning that the variable names and data values are separated by commas in the file. 

Consider the contents of the `test_1.csv` file.

```{r comment = ''}
cat(readLines("data/test_1.csv"), sep = "\n")
```

### 

Write code to read this file into R using `read_csv()`, setting the `file` argument to `"data/test_1.csv"`.

```{r reading-data-from-a-file-10, exercise = TRUE}

```

```{r reading-data-from-a-file-10-hint-1, eval = FALSE}
read_csv(file = ...)
```

```{r reading-data-from-a-file-10-solution, exercise.reveal_solution = FALSE}
read_csv(file = "data/test_1.csv")
```

```{r reading-data-from-a-file-10-check}
grade_this_code()
```

### 

The message provides information about the size of the data set.

### 

R then provides some information about the columns in the data set. The column specification message is a *suggestion* from R to you to specify the data types for each column of data. R "guesses" a data type unless we use the `col_types` argument. 


### Exercise 11

Make the message disappear by setting the `show_col_types` argument to `FALSE`.

```{r reading-data-from-a-file-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-a-file-11-hint-1, eval = FALSE}
read_csv(file = "data/test_1.csv", show_col_types = ...)
```

```{r reading-data-from-a-file-11-solution, exercise.reveal_solution = FALSE}
read_csv("data/test_1.csv", show_col_types = FALSE)
```

```{r reading-data-from-a-file-11-check}
grade_this_code()
```

### 

It is always better to use the `col_types` argument explicitly in order to ensure that the variable types are what you want them to be. 

R is trying to be helpful by nagging you with that message. It is saying "Don't you want to specify the column types for this data? That would be a good idea!"


### Exercise 12

Consider the contents of the `test_2.csv` file. 

```{r comment = ''}
cat(readLines("data/test_2.csv"), sep = "\n")
```

### 

Write code for skipping the text at the top of `"data/test_2.csv"` by setting the second argument `skip` to the appropriate number.

```{r reading-data-from-a-file-12, exercise = TRUE}

```

```{r reading-data-from-a-file-12-hint-1, eval = FALSE}
read_csv(file = "data/test_2.csv", skip = ...)
```

```{r reading-data-from-a-file-12-solution, exercise.reveal_solution = FALSE}
read_csv("data/test_2.csv", skip = 2)
```

```{r reading-data-from-a-file-12-check}
grade_this_code()
```

### 

The argument `skip` is used to skip rows, but to skip columns, you can use the `col_only()` function as the argument to `col_types` in order to read in only the columns which you want. 

### Exercise 13

Consider the contents of the `test_3.csv` file. 

```{r comment = ''}
cat(readLines("data/test_3.csv"), sep = "\n")
```

### 

Write code that will create default names for `"data/test_3.csv"` by setting the `col_names` argument to `FALSE`.

```{r reading-data-from-a-file-13, exercise = TRUE}

```

```{r reading-data-from-a-file-13-hint-1, eval = FALSE}
read_csv(file = "data/test_3.csv", col_names = ...)
```

```{r reading-data-from-a-file-13-solution, exercise.reveal_solution = FALSE}
read_csv("data/test_3.csv", col_names = FALSE)
```

```{r reading-data-from-a-file-13-check}
grade_this_code()
```

### 

The result when your code is run should look like this:

```{r comment = ''}
read_csv("data/test_3.csv", col_names = FALSE)
```

### 

The argument `col_names` can also be used to create custom column names. 


### Exercise 14

Consider the contents of the `test_6.csv` file.

```{r comment = ''}
cat(readLines("data/test_6.csv"), sep = "\n")
```

### 

Write code for skipping the text lines within `"data/test_6.csv"` by setting the `comment` argument to `"#"`.

```{r reading-data-from-a-file-14, exercise = TRUE}

```

```{r reading-data-from-a-file-14-hint-1, eval = FALSE}
read_csv(file = "data/test_6.csv", comment = "...")
```

```{r reading-data-from-a-file-14-solution, exercise.reveal_solution = FALSE}
read_csv("data/test_6.csv", comment = "#")
```

```{r reading-data-from-a-file-14-check}
grade_this_code()
```

### 

It doesn't always have to be "#", it can be any character that designates a line as a comment!

### Exercise 15

CSV files are just one type of **text** file. A text file is any file which includes plain text. The contents of such files are easy to look at in any text editor, or in RStudio.

Consider the contents of the text file `delim_1.txt`:

```{r}
cat(readLines("data/delim_1.txt"), sep = "\n")
```

### 

Write code for reading this file in to R. The values in the file are separated by pipes rather than commas. So, instead of `read_csv()`, you should use `read_delim()`. Don't forget that the `delim_1.txt` file, like all the files in this tutorial, is in the `data` directory. 

```{r reading-data-from-a-file-15, exercise = TRUE}

```

```{r reading-data-from-a-file-15-hint-1, eval = FALSE}
read_delim(file = ..., delim = ...)
```

```{r reading-data-from-a-file-15-hint-2, eval = FALSE}
Set the `file` argument to "data/delim_1.txt". 
Also use the `delim` argument and set it to "|".
```

```{r reading-data-from-a-file-15-solution, exercise.reveal_solution = FALSE}
read_delim(file = "data/delim_1.txt", delim = "|")
```

```{r reading-data-from-a-file-15-check}
grade_this_code()
```

### 

The result when your code is run should look like this:

```{r comment = ''}
read_delim("data/delim_1.txt", delim = "|")
```

### 

Note how the spaces and commas are included in the values for `town`. You can't use `read_csv()` here because not all the columns are denoted by commas.


## Controlling column types
### 

A CSV file doesn’t contain any information about the type of each variable (i.e. whether it’s a logical, number, string, etc.), so **readr** will try to guess the type. This section describes how the guessing process works, how to resolve some common problems that cause it to fail, and, if needed, how to supply the column types yourself. 


### Exercise 1

In this tutorial, we will make use of the "quotation trick" which allows `read_csv()` and related functions to read data directly from a quoted string, rather than a file. As an example, run this code by clicking "Submit Answer":


```{r controlling-column-types-1, exercise = TRUE}
read_csv("
  a, b, c
  1, 2, 3
")
```

```{r controlling-column-types-1-solution, exercise.reveal_solution = FALSE}
read_csv("
  a, b, c
  1, 2, 3
")
```

```{r controlling-column-types-1-check}
grade_this_code()
```

### 

This produces the same tibble as if the character string were in a separate file.

### Exercise 2

**readr** uses a heuristic to figure out the column types. For each column, it pulls the values of 1,000 rows spaced evenly from the first row to the last, ignoring missing values. It then works through the following questions:

* Does it contain only `F`, `T`, `FALSE`, or `TRUE` (ignoring case)? If so, it’s a logical.
* Does it contain only numbers (e.g., `1`, `-4.5`, `5e6`, `Inf`)? If so, it’s a number.
* Does it match the ISO8601 standard? If so, it’s a date or date-time. 
* Otherwise, it must be a string.

###

Consider the contents of the `test_8.csv` file.

```{r comment = ''}
cat(readLines("data/test_8.csv"), sep = "\n")
```

Read in the data with the `read_csv()` function and set the `file` argument to `"data/test_8.csv"`.


```{r controlling-column-types-2, exercise = TRUE}

```

```{r controlling-column-types-2-hint-1, eval = FALSE}
read_csv(...)
```

```{r controlling-column-types-2-solution, exercise.reveal_solution = FALSE}
read_csv(file = "data/test_8.csv")
```

```{r controlling-column-types-2-check}
grade_this_code()
```

### 

The first row is just treated as a column name by `read_csv()`. It does not use this information when determining variable types.



### Exercise 3

The most common way column detection fails is that a column contains unexpected values, resulting in a character column instead of a more specific type. One of the most common causes for this is a missing value, recorded using something other than the `NA` that **readr** expects. Press "Submit Answer".

```{r controlling-column-types-3, exercise = TRUE}
simple_csv <- "
  x
  10
  .
  20
  30"

read_csv(simple_csv)
```

```{r controlling-column-types-3-solution, exercise.reveal_solution = FALSE}
simple_csv <- "
  x
  10
  .
  20
  30"

read_csv(simple_csv)
```

```{r controlling-column-types-3-check}
grade_this_code()
```

### 

Note how `x` is read in as a character column when, obviously, it should be a number. In this very small case, you can easily see the missing value `.`. But what happens if you have thousands of rows with only a few missing values represented by `.`s speckled among them?

### Exercise 4

One approach is to tell `read_csv()` that `x` is a numeric column, and then see where it fails. We can do that with the `col_types` argument, which takes a named list where the names match the column names in the CSV file. Run `read_csv()` with `simple_csv` as the first argument and `col_types = list(x = col_double())` as the second.

```{r controlling-column-types-4, exercise = TRUE}

```

```{r controlling-column-types-4-hint-1, eval = FALSE}
read_csv(
  simple_csv, 
  ... = list(x = col_double())
)
```

```{r controlling-column-types-4-solution, exercise.reveal_solution = FALSE}
read_csv(
  simple_csv, 
  col_types = list(x = col_double())
)
```

```{r controlling-column-types-4-check}
grade_this_code()
```

### 

This worked in that `x` is a `<dbl>`. R has two built-in number variable types: integers and doubles. But how can we investigate the warning?

### Exercise 5

Take the call to `read_csv()` from the previous question and assign the output to an object called `df`. Then, in the next line, run `problems()` on `df`.

```{r controlling-column-types-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r controlling-column-types-5-hint-1, eval = FALSE}
... <- read_csv(
  simple_csv, 
  col_types = list(x = col_double())
)

problems(...)
```

```{r controlling-column-types-5-solution, exercise.reveal_solution = FALSE}
df <- read_csv(
  simple_csv, 
  col_types = list(x = col_double())
)

problems(df)
```

```{r controlling-column-types-5-check}
grade_this_code()
```

### 

This tells us that there was a problem in row 3, col 1 where **readr** expected a double but got a `.`. That suggests this dataset uses `.` for missing values. Real world data sets will often have many more issues but, with tools like `problems()`, you can solve them one-by-one.

### Exercise 6

Since we know that `.` means a missing value in this data, we can now call `read_csv()` on `simple_csv` with the `na` argument set to `"."`.

```{r controlling-column-types-6, exercise = TRUE}

```

```{r controlling-column-types-6-hint-1, eval = FALSE}
read_csv(simple_csv, ... = ".")
```

```{r controlling-column-types-6-solution, exercise.reveal_solution = FALSE}
# option_1 ----
read_csv(simple_csv, na = ".")

# option_2 ----
read_csv(simple_csv, na = c("."))

# option_3 ----
read_csv(simple_csv, na = c(".", ""))
```

```{r controlling-column-types-6-check}
grade_this_code()
```

### 

**readr** provides a total of nine column types for you to use. Here are the most important 4.

* `col_logical()` and `col_double()` read logicals and real numbers. They’re relatively rarely needed (except as above), since **readr** will usually guess them for you.

* `col_integer()` reads integers. We seldom distinguish integers and doubles because they’re functionally equivalent, but reading integers explicitly can occasionally be useful because they occupy half the memory of doubles.

* `col_character()` reads strings. This is sometimes useful to specify explicitly when you have a column that is a numeric identifier, i.e. long series of digits that identifies some object, but it doesn’t make sense to (e.g.) divide it in half, for example, a phone number, social security number, credit card number, etc.


### Exercise 7

It’s also possible to override the default column by switching from `list()` to `cols()` and specifying `.default`. 

###

Consider an object called `another_csv` defined below.

```{r comment = '', echo = TRUE, eval = FALSE}
another_csv <- "
  x,y,z
  1,2,3
"
```

###

Use `read_csv()` on `another_csv` with the `col_types` argument set to `cols(.default = col_character()`.

```{r controlling-column-types-7-setup}
another_csv <- "
x,y,z
1,2,3
"
```

```{r controlling-column-types-7, exercise = TRUE}

```

```{r controlling-column-types-7-hint-1, eval = FALSE}
read_csv(
  another_csv, 
  ... = cols(... = col_character())
)
```

```{r controlling-column-types-7-solution, exercise.reveal_solution = FALSE}
read_csv(
  another_csv, 
  col_types = cols(.default = col_character())
)
```

```{r controlling-column-types-7-check}
grade_this_code()
```

### 

Here are the other 5 column types from **readr**.

* `col_factor()`, `col_date()`, and `col_datetime()` create factors, dates, and date-times respectively.

* `col_number()` is a permissive numeric parser that will ignore non-numeric components, and is particularly useful for currencies.

* `col_skip()` skips a column so it’s not included in the result, which can be useful for speeding up reading the data if you have a large CSV file and you only want to use some of the columns.

### Exercise 8

Another useful helper is `cols_only()` which will read in only the columns you specify. Run `read_csv()` on `another_csv` with the `col_types` argument set to `cols_only(x = col_character()`.


```{r controlling-column-types-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r controlling-column-types-8-hint-1, eval = FALSE}
read_csv(
  another_csv,
  col_types = ...(x = ...)
)
```

```{r controlling-column-types-8-solution, exercise.reveal_solution = FALSE}
read_csv(
  another_csv,
  col_types = cols_only(x = col_character())
)
```

```{r controlling-column-types-8-check}
grade_this_code()
```

### 

The [help page](https://readr.tidyverse.org/reference/cols.html) for `cols()` includes more details and discussion.

<!-- The rest of the material in this section is not in R4DS. But it is good stuff! So, for now, I keep it. -->

<!-- ### Exercise 9 -->

<!-- Consider another example file: -->

<!-- ```{r controlling-column-types-9-setup} -->
<!-- cat(readLines("data/ex_2.csv"), sep = "\n") -->
<!-- ``` -->

<!-- Read the `data/ex_2.csv` file into R to check if there are any parsing mistakes. -->

<!-- ```{r controlling-column-types-ex-9, exercise = TRUE} -->

<!-- ``` -->

<!-- ```{r controlling-column-types-9-hint-1, eval = FALSE} -->
<!-- read_csv("data/ex_2.csv") -->
<!-- ``` -->

<!-- ```{r controlling-column-types-9-test, include = FALSE} -->
<!-- read_csv("data/ex_2.csv") -->
<!-- ``` -->

<!-- ###  -->

<!-- Notice that R parses column `a` and `b` both as a doubles. But what if column `a` should be parsed as an integer and column `b` should be parsed as a date? -->

<!-- ### Exercise 10 -->

<!-- ```{r controlling-column-types-10-setup} -->
<!-- cat(readLines("data/ex_2.csv"), sep = "\n") -->
<!-- ``` -->

<!-- Begin by using `read_csv()` to read in the file `ex_2.csv`. Then, set the `col_types` argument to `cols()`. Within `cols()`, set `.default` to `col_character()`. -->

<!-- ```{r controlling-column-types-ex-10, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r controlling-column-types-10-hint-1, eval = FALSE} -->
<!-- read_csv(...,  -->
<!--          col_types = cols(.default = ...) -->
<!-- ) -->
<!-- ``` -->

<!-- ```{r controlling-column-types-10-test, include = FALSE} -->
<!-- read_csv("data/ex_2.csv",  -->
<!--          col_types = cols(.default = col_character()) -->
<!-- ) -->
<!-- ``` -->

<!-- This is not what we want. But it is often convenient to read in a new file as all character variables. It is then easier to examine its contents directly. -->

<!-- ### Exercise 11 -->

<!-- ```{r controlling-column-types-11-setup} -->
<!-- cat(readLines("data/ex_2.csv"), sep = "\n") -->
<!-- ``` -->

<!-- Pipe the results of `read_csv()` to the function `mutate()`. Within `mutate()` set `a` to `parse_integer(a)`.  -->

<!-- ```{r controlling-column-types-ex-11, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r controlling-column-types-11-hint-1, eval = FALSE} -->
<!-- ... |>  -->
<!--     mutate(a = ...) -->
<!-- ``` -->

<!-- ```{r controlling-column-types-11-test, include = FALSE} -->
<!-- read_csv("data/ex_2.csv",  -->
<!--          col_types = cols(.default = col_character()) -->
<!--          ) |>  -->
<!--   mutate(a = parse_integer(a)) -->
<!-- ``` -->

<!-- ###  -->

<!-- You can also use `parse_number()` but the resulting variable will be a `<dbl>`, not an `<int>`. -->

<!-- ### Exercise 12 -->

<!-- ```{r controlling-column-types-12-setup} -->
<!-- cat(readLines("data/ex_2.csv"), sep = "\n") -->
<!-- ``` -->

<!-- Continue your pipe with `mutate()`. Use `parse_date()` to transform `b` to dates. The first argument to `parse_date()` should be `b`. The second argument should be `format`. Set `format` to `"%Y%M%D"`. -->

<!-- ```{r controlling-column-types-ex-12, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r controlling-column-types-12-hint-1, eval = FALSE} -->
<!-- ... |>  -->
<!--   mutate(b = parse_date(b, format = "...")) -->
<!-- ``` -->

<!-- ```{r controlling-column-types-12-test, include = FALSE} -->
<!-- read_csv("data/ex_2.csv",  -->
<!--          col_types = cols(.default = col_character()) -->
<!--          ) |>  -->
<!--   mutate(a = parse_integer(a)) |>  -->
<!--   mutate(b = parse_date(b, format = "%Y%M%D")) -->
<!-- ``` -->

<!-- ###  -->

<!-- `"%Y%M%D"` tells R to read the number as a date (Y for year, M for month, D for date).  -->

<!-- ### Exercise 13 -->

<!-- Let's explore one last file, `ex_3.csv`, that has parsing problems. -->

<!-- ```{r controlling-column-types-13-setup} -->
<!-- cat(readLines("data/ex_3.csv"), sep = "\n") -->
<!-- ``` -->

<!--  Run `read_csv("data/ex_3.csv")` and examine the parsing failures. -->

<!-- ```{r controlling-column-types-ex-13, exercise = TRUE} -->

<!-- ``` -->

<!-- ```{r controlling-column-types-13-hint-1, eval = FALSE} -->
<!-- read_csv(...) -->
<!-- ``` -->

<!-- ```{r controlling-column-types-13-test, include = FALSE} -->
<!-- read_csv("data/ex_3.csv") -->
<!-- ``` -->

<!-- ###  -->

<!-- What are the problems here? First, R parses column `x` as a character, when it is clearly a date. Also, column `z` should be parsed as an integer not a character! -->

<!-- ### Exercise 14 -->

<!-- ```{r controlling-column-types-14-setup} -->
<!-- cat(readLines("data/ex_3.csv"), sep = "\n") -->
<!-- ``` -->

<!-- Let's first fix column `x`. Pipe the results of `read_csv("data/ex_3.csv")` to the function `mutate()`. Within `mutate()` set `x` equal to `parse_date(x, "%d %B %Y")`.   -->

<!-- ```{r controlling-column-types-ex-14, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r controlling-column-types-14-hint-1, eval = FALSE} -->
<!-- ... |>  -->
<!--     mutate(x = parse_date(...)) -->
<!-- ``` -->

<!-- ```{r controlling-column-types-14-test, include = FALSE} -->
<!-- read_csv("data/ex_3.csv") |>  -->
<!--   mutate(x = parse_date(x, "%d %B %Y")) -->
<!-- ``` -->

<!-- ###  -->

<!-- The `%d` signifies that there's only 1 digit for the day, the `%B` means that we're using the name of the month rather than the number, and the spaces in between represent the spaces in between each value. By customizing our format string, we can easily parse any format of dates without any problems. -->

<!-- Also note that we did not need to use the `.default = col_character()` trick before we used `mutate()`. Why? Because R already read all of the columns as characters to begin with. -->

<!-- ### Exercise 15 -->

<!-- ```{r controlling-column-types-15-setup} -->
<!-- cat(readLines("data/ex_3.csv"), sep = "\n") -->
<!-- ``` -->

<!-- Continue your pipe with `mutate()`. Within `mutate()` set `z` to `parse_number(z)`.  -->

<!-- ```{r controlling-column-types-ex-15, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r controlling-column-types-15-hint-1, eval = FALSE} -->
<!-- ... |>  -->
<!--     mutate(z = parse_number(...)) -->
<!-- ``` -->

<!-- ```{r controlling-column-types-15-test, include = FALSE} -->
<!-- read_csv("data/ex_3.csv") |>  -->
<!--   mutate(x = parse_date(x, "%d %B %Y")) |>  -->
<!--   mutate(z = parse_number(z)) -->
<!-- ``` -->

<!-- `parse_number()` is good at dealing with currency signs and other detritus.  -->


## Reading data from multiple files
### 

Cleaning multiple files at once is a common task.

### Exercise 1

Run `list.files("data")` to check what files there are in the `data` folder.

```{r reading-data-from-multiple-fil-1, exercise = TRUE}

```

```{r reading-data-from-multiple-fil-1-hint-1, eval = FALSE}
...("data")
```

```{r reading-data-from-multiple-fil-1-solution, exercise.reveal_solution = FALSE}
list.files("data")
```

```{r reading-data-from-multiple-fil-1-check}
grade_this_code()
```

### 

The `list.files()` function is part of base R.  Check out its [help page](https://stat.ethz.ch/R-manual/R-devel/library/base/html/list.files.html).

<!-- ### Exercise 2 -->

<!-- Change the call to `list.files("data")` by setting the argument `pattern` to `"similar"` to only look at the files with the names "similar" in them. -->

<!-- ```{r reading-data-from-multiple-fil-2, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r reading-data-from-multiple-fil-2-hint-1, eval = FALSE} -->
<!-- list.files("data", ... = "similar") -->
<!-- ``` -->

<!-- ```{r reading-data-from-multiple-fil-2-solution, exercise.reveal_solution = FALSE} -->
<!-- list.files("data", pattern = "similar") -->
<!-- ``` -->

<!-- ```{r reading-data-from-multiple-fil-2-check} -->
<!-- grade_this_code() -->
<!-- ``` -->

<!-- ###  -->

<!-- The result when your code is run should look like this: -->

<!-- ```{r} -->
<!-- list.files("data", pattern = "similar") -->
<!-- ``` -->

<!-- ###  -->

<!-- You can also set `pattern` to ".csv" or ".delim" for those types of files in a folder. -->

<!-- ### Exercise 3 -->

<!-- To show the exact directory of where the files came from, set the argument `full.names` to `TRUE` in `list.files()`. -->

<!-- ```{r reading-data-from-multiple-fil-ex-3, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r reading-data-from-multiple-fil-3-hint-1, eval = FALSE} -->
<!-- list.files("data", pattern = "similar", full.names = ...) -->
<!-- ``` -->

<!-- ```{r reading-data-from-multiple-fil-3-solution, exercise.reveal_solution = FALSE} -->
<!-- list.files("data", pattern = "similar", full.names = TRUE) -->
<!-- ``` -->

<!-- ```{r reading-data-from-multiple-fil-3-check} -->
<!-- grade_this_code() -->
<!-- ``` -->

<!-- ###  -->

<!-- The result when your code is run should look like this: -->

<!-- ```{r} -->
<!-- list.files("data", pattern = "similar", full.names = TRUE) -->
<!-- ``` -->

<!-- ### Exercise 4 -->

<!-- These are the contents of `similar_1.csv`, `similar_2.csv`, `similar_3.csv`, respectively. -->

<!-- ```{r} -->
<!-- cat(readLines("data/similar_1.csv"), sep = "\n") -->
<!-- cat(readLines("data/similar_2.csv"), sep = "\n") -->
<!-- cat(readLines("data/similar_3.csv"), sep = "\n") -->
<!-- ``` -->

<!-- ###  -->

<!-- Now let's combine the files by piping the last call to `list_files()` directly to `read_csv()`! -->

<!-- ```{r reading-data-from-multiple-fil-ex-4, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r reading-data-from-multiple-fil-4-hint-1, eval = FALSE} -->
<!-- list.files("data",  -->
<!--            pattern = "similar",  -->
<!--            full.names = TRUE) |>  -->
<!--   ... -->
<!-- ``` -->

<!-- ```{r reading-data-from-multiple-fil-4-solution, exercise.reveal_solution = FALSE} -->
<!-- list.files("data",  -->
<!--            pattern = "similar",  -->
<!--            full.names = TRUE) |>  -->
<!--   read_csv() -->
<!-- ``` -->

<!-- ```{r reading-data-from-multiple-fil-4-check} -->
<!-- grade_this_code() -->
<!-- ``` -->

<!-- ###  -->

<!-- Column `b`'s type is `chr` because the "." in `similar_1.csv` makes R think the rest of the column are characters. We will fix that using the `na` argument in `read_csv()`. -->

<!-- ### Exercise 5 -->

<!-- Using the same pipleline, change `read_csv()` to set the argument `na` to `"."` to get rid of the character in column `b`. -->

<!-- ```{r reading-data-from-multiple-fil-ex-5, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r reading-data-from-multiple-fil-5-hint-1, eval = FALSE} -->
<!-- ... |>  -->
<!--   read_csv(... = ".") -->
<!-- ``` -->

<!-- ```{r reading-data-from-multiple-fil-5-solution, exercise.reveal_solution = FALSE} -->
<!-- list.files("data",  -->
<!--            pattern = "similar",  -->
<!--            full.names = TRUE) |>  -->
<!--   read_csv(na = ".") -->
<!-- ``` -->

<!-- ```{r reading-data-from-multiple-fil-5-check} -->
<!-- grade_this_code() -->
<!-- ``` -->

<!-- ###  -->

<!-- The result when your code is run should look like this: -->

<!-- ```{r} -->
<!-- list.files("data", pattern = "similar", full.names = TRUE) |>  -->
<!--   read_csv(na = ".") -->
<!-- ``` -->

<!-- ###  -->

<!-- Because the "." is gone, column `b`'s type is `dbl` now.  -->

<!-- ### Exercise 6 -->

<!-- Now let's get rid of the annoying "specify column types" message by using the `show_col_types` argument. In the call to `read_csv()`, add the `show_col_types` argument to `FALSE`. -->

<!-- ```{r reading-data-from-multiple-fil-ex-6, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r reading-data-from-multiple-fil-6-hint-1, eval = FALSE} -->
<!-- ... |>  -->
<!--   read_csv(na = ".", ... = FALSE) -->
<!-- ``` -->

<!-- ```{r reading-data-from-multiple-fil-6-solution, exercise.reveal_solution = FALSE} -->
<!-- list.files("data",  -->
<!--            pattern = "similar",  -->
<!--            full.names = TRUE) |>  -->
<!--   read_csv(na = ".", show_col_types = FALSE) -->
<!-- ``` -->

<!-- ```{r reading-data-from-multiple-fil-6-check} -->
<!-- grade_this_code() -->
<!-- ``` -->

<!-- ###  -->

<!-- You can use the other arguments of `read_csv()` to further clean your files, such as `col_names`, `col_types`, or `skip`.  -->

### Exercise 2

Consider the three sales files currently in the `data` directory. 

Change the call to `list.files("data")` by setting the argument `pattern` to `"sales"` to only look at the files with the names "sales" in them.


```{r reading-data-from-multiple-fil-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-multiple-fil-2-hint-1, eval = FALSE}
list.files(
  path = ..., 
  pattern = ...
)
```

```{r reading-data-from-multiple-fil-2-solution, exercise.reveal_solution = FALSE}
list.files(
  path = "data", 
  pattern = "sales"
)
```

```{r reading-data-from-multiple-fil-2-check}
grade_this_code()
```

### 

Although there are only 3 files here, in many cases you will need to deal with hundreds or even thousands of files.

### Exercise 3

Take the code from the last exercise and pipe it to `read_csv()`. In the `list.files()` call add `full.names = TRUE`, otherwise `read_csv()` won't be able to *find* the files.

```{r reading-data-from-multiple-fil-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-multiple-fil-3-hint-1, eval = FALSE}
list.files(
  path = "data",
  pattern = 'sales', 
  full.names = ...
  ) |> 
  ...
```

```{r reading-data-from-multiple-fil-3-solution, exercise.reveal_solution = FALSE}
list.files(
  path = "data",
  pattern = 'sales', 
  full.names = TRUE
  ) |> 
  read_csv()
```

```{r reading-data-from-multiple-fil-3-check}
grade_this_code()
```

### 

Although this works, we have lost the information about which rows come from which input files. This is important because the file names tell us which month the data is from.

### Exercise 4

Using the same code as above, add the `id` argument to `read_csv()` with a value of `"file"`.

```{r reading-data-from-multiple-fil-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-multiple-fil-4-hint-1, eval = FALSE}
list.files(
  path = "data",
  pattern = 'sales', 
  full.names = TRUE
  ) |> 
  read_csv(... = "file")
```

```{r reading-data-from-multiple-fil-4-solution, exercise.reveal_solution = FALSE}
list.files(
  path = "data",
  pattern = 'sales', 
  full.names = TRUE
  ) |> 
  read_csv(id = "file")
```

```{r reading-data-from-multiple-fil-4-check}
grade_this_code()
```

### 

This is especially helpful in circumstances where the files you’re reading in do not have an identifying column that can help you trace the observations back to their original sources. It is often useful to know the "provenance" of a given piece of data. If something seems wrong later in the process, we will want to track it back to its original source.


## Writing to a file
### 

**readr** also comes with two useful functions for writing data back to disk: `write_csv()` and `write_tsv()`. The most important arguments to these functions are `x` (the data frame or tibble to write) and `file` (the location to write it to). You can also specify how missing values are written with `na`, and if you want to `append` to an existing file.

### Exercise 1

Let's first create a new R object, `students2` which is the result of the clean up we did above on the original "students.csv" file. Press "Submit Answer".

```{r writing-to-a-file-1, exercise = TRUE}
students2 <- students |> 
  janitor::clean_names() |> 
  mutate(
    meal_plan = factor(meal_plan),
    age = if_else(age == "five", "5", age),
    age = parse_number(age)
  )

students2
```

```{r writing-to-a-file-1-solution, exercise.reveal_solution = FALSE}
students2 <- students |> 
  janitor::clean_names() |> 
  mutate(
    meal_plan = factor(meal_plan),
    age = if_else(age == "five", "5", age),
    age = parse_number(age)
  )

students2
```

```{r writing-to-a-file-1-check}
grade_this_code()
```

### 

This workflow is very common. First, we interactively add code, line-by-line, to a pipe, running the entire pipe each time, examining the output as it is "spat" back to the screen. Second, once the pipe produces what we want, then we add an object, `students2` in this case, to the front of the pipe and create a permanent object which we can then work with.

### Exercise 2

Type `students2` and hit Submit Code. This will produce the same output as `print(students2)`. That is, hitting Return on an R object is the same thing as explicitly printing that object.

```{r writing-to-a-file-2, exercise = TRUE}

```

```{r writing-to-a-file-2-hint-1, eval = FALSE}
students2
```

```{r writing-to-a-file-2-solution, exercise.reveal_solution = FALSE}
students2
```

```{r writing-to-a-file-2-check}
grade_this_code()
```

### 

`students2` has been cleaned up from the original "students.csv", most importantly in terms the variable names. Note that `mean_plan` is a `<fct>`, meaning a factor.

### Exercise 3

<!-- There does not seem to be a way for students to write out a file to a location to which they will have access for reading. So, we need to stick students2.csv in data/ ahead of time, while pretending that students are doing it. -->

Use `write_csv()` to write the contents of the `students2` object to a file called `"students2.csv"` which should be placed in the `data` directory.  Do this by setting the first argument of `write_csv()`, `x`, to `students2` and then the second argument, `file`, to `"data/students2.csv"`.


```{r writing-to-a-file-3, exercise = TRUE}

```

```{r writing-to-a-file-3-hint-1, eval = FALSE}
write_csv(
  x = ..., 
  ... = "data/students2.csv"
  )
```

```{r writing-to-a-file-3-solution, exercise.reveal_solution = FALSE}
write_csv(
  x = students2, 
  file = "data/students2.csv"
  )
```

```{r writing-to-a-file-3-check}
grade_this_code()
```

### 

As with many commonly used functions, we will often drop the argument names. In that case, we would typically write `write_csv(students2, "data/students2.csv")`.

### Exercise 4

Now let’s read that csv file back in. Run `read_csv()` on `"data/students2.csv"`.

```{r writing-to-a-file-4, exercise = TRUE}

```

```{r writing-to-a-file-4-hint-1, eval = FALSE}
...("data/students2.csv")
```

```{r writing-to-a-file-4-solution, exercise.reveal_solution = FALSE}
read_csv("data/students2.csv")
```

```{r writing-to-a-file-4-check}
grade_this_code()
```

### 

Note that variable type information is lost when you save to CSV because you’re starting over by reading from a plain text file again. `meal_plan` is now `<chr>`, meaning a character variable.

This makes CSVs a little unreliable for caching interim results --- you need to recreate the column specification every time you load in. There are two main alternative: `write_rds()` with`read_rds()` and `write_parquet()`.

### Exercise 5

RDS files store R objects in a file which can be saved on your computer. Then, if you come back to a project, even after restarting R, you can quickly load back the object, without redoing all the code which created it.

###

This time use `write_rds()` to write the contents of the `students2` object to a file called `"students2.rds"` which should be placed in the `data` directory. Do this by setting the first argument of `write_rds()`, `x`, to `students2` and then the second argument, `file`, to `"data/students2.rds"`.


```{r writing-to-a-file-5, exercise = TRUE}

```

```{r writing-to-a-file-5-hint-1, eval = FALSE}
write_rds(
  x = ..., 
  ... = "data/students2.csv"
)
```

```{r writing-to-a-file-5-solution, exercise.reveal_solution = FALSE}
write_rds(x = students2, file = "data/students2.rds")
```

```{r writing-to-a-file-5-check}
grade_this_code()
```

<!-- ###  -->

<!-- The big advantage of creating an rds file is that we can reload the object it contains later, without re-running the code which created it.   -->

### Exercise 6

Let's now use `read_rds()` to read in the newly created file! Set the `file` argument to `"data/students2.rds"`.

```{r writing-to-a-file-6, exercise = TRUE}

```

```{r writing-to-a-file-6-hint-1, eval = FALSE}
read_rds(... = "data/students2.rds")
```

```{r writing-to-a-file-6-solution, exercise.reveal_solution = FALSE}
read_rds(file = "data/students2.rds")
```

```{r writing-to-a-file-6-check}
grade_this_code()
```

### 

Datasets are just one example of what we can store in a rds file. We can also store plots or any R object.

###

`write_rds()` and `read_rds()` are not the best approach for working with large data sets. In that case, use the functions `write_parquet()` and  `read_parquet()` from the [**arrow**](https://arrow.apache.org/) package.

###

Parquet tends to be much faster than RDS and is usable outside of R, but does require the **arrow** package.

## Data entry
### 

Sometimes you’ll need to assemble a tibble “by hand” doing a little data entry in your R script. There are two useful functions to help you do this which differ in whether you layout the tibble by columns (`tibble()`) or by rows (`tribble()`).

### Exercise 1

Create a tibble by using the `tibble()` function. Pass three arguments to `tibble()`, which are the three variables you want to include in the new tibble: `x = c(1, 2, 5)`, `y = c("h", "m", "g")`, and `z = c(0.08, 0.83, 0.60)`. Don't forget to separate input arguments with commas.


```{r data-entry-1, exercise = TRUE}

```

```{r data-entry-1-hint-1, eval = FALSE}
tibble(
  x = ..., 
  ... = c("h", "m", "g"),
  ... = ...
)
```

```{r data-entry-1-solution, exercise.reveal_solution = FALSE}
tibble(
  x = c(1, 2, 5),
  y = c("h", "m", "g"),
  z = c(0.08, 0.83, 0.60)
)
```

```{r data-entry-1-check}
grade_this_code()
```
### 

Laying out the data by column can make it hard to see how the rows are related, so an alternative is `tribble()`, short for **tr**ansposed t**ibble**, which lets you lay out your data row by row.

### Exercise 2

Use `tribble()` to create the same tibble as in the previous question. Use the Hint to get started.

```{r data-entry-2, exercise = TRUE}

```

```{r data-entry-2-hint-1, eval = FALSE}
tribble(
  ~x, ..., ~z,
  1, "h", ...,
  2, ..., 0.83,
  5, "g", ...
)
```

```{r data-entry-2-solution, exercise.reveal_solution = FALSE}
tribble(
  ~x, ~y, ~z,
  1, "h", 0.08,
  2, "m", 0.83,
  5, "g", 0.60
)
```

```{r data-entry-2-check}
grade_this_code()
```
### 

The difference between the name `tibble()` and the name `tribble()` is one letter: *r*. The *r* stands for **r**ows since `tribble()` allows you to type in the data by row.

## Summary
### 

This tutorial covered [Chapter 7: Data import](https://r4ds.hadley.nz/data-import.html) from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. You learned how to import data into your R project using [`read_csv()`](https://readr.tidyverse.org/reference/read_delim.html) and related functions from the [**readr**](https://readr.tidyverse.org/) package. You also learned how to write out data to files with functions like [`write_csv()`](https://readr.tidyverse.org/reference/write_delim.html).

The **[janitor](https://sfirke.github.io/janitor/)** package includes a variety of useful functions, especially [`clean_names()`](https://sfirke.github.io/janitor/reference/clean_names.html).

Once you are finished:

-   Click the 'Download Grade' button below. This will download an html document of your grade summary.
-   Submit the downloaded html to your learning management system.

```{r}
grade_print_ui("grade")
```

